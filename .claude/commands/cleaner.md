# Project Refiner

This plan outlines the sequential, non-interactive process for analyzing a disorganized collection of files generated by an AI agent and automatically refactoring them into a human-readable, maintainable project structure.

## Core Process

### **Step 1: Ingestion & Inventory**

Initiate the process by scanning all existing files and directories within the specified project directory. Create an in-memory list of their metadata (filename, extension, last modified date, etc.).

### **Step 2: Content-based Classification**

Analyze the content of each file in the inventory. Intelligently classify each file into a primary category—such as "source code," "test code," "documentation," or "configuration"—based on its syntax, keywords (e.g., `import`, `class`, `test`), and file extension. This step also identifies the primary programming language used.

### **Step 3: Dependency & Relationship Analysis**

Analyze the dependencies within the classified source code (e.g., `import` statements, function calls) to map the project's architecture. This identifies the application's entry points, key modules, and their relationships.

### **Step 4: Best-Practice Configuration Definition**

Research and identify the established **best practices and standard project structure** for the identified programming language (e.g., Python, Go, Rust). Based on that structure, define the optimal directory layout (e.g., use of `src/` or a project name directory, separation of `cmd/` and `pkg/`). Concurrently, generate the appropriate content for a `.gitignore` file based on the identified language and frameworks.

### **Step 5: File Relocation & Configuration**

Relocate the classified files to their appropriate locations according to the best-practice structure defined in Step 4. During this process, attempt to automatically fix relative path references in the source code to prevent breakage. In parallel, create or overwrite the `.gitignore` file in the project root with the defined content.

### **Step 6: Waste Identification & Deletion**

Identify files that could not be classified into any category, are clearly temporary (e.g., `*.tmp`, `*.log`), or are determined to be duplicates. Delete these files directly from the file system.

### **Step 7: Post-Refactoring Test Execution**

To verify the integrity of the refactored project, automatically detect the test framework (e.g., `pytest`, `jest`) and execute the entire test suite. This confirms that the refactoring process has not broken any existing functionality.

## **Execution**

Proceed with the execution of the 7-step plan in sequence. The entire process is to be completed autonomously without further user interaction. Upon completion, confirm that the project has been successfully refactored and that all tests pass.
